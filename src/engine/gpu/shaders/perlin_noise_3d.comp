#version 450 core

// Robin Engine - 3D Perlin Noise Compute Shader
// High-performance GPU-based 3D Perlin noise generation for volumetric data

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

// Output 3D texture for noise values
layout(r32f, binding = 0) uniform writeonly image3D noise_output;

// Uniform parameters
layout(binding = 1) uniform NoiseParams3D {
    float frequency;
    float amplitude;
    int octaves;
    float persistence;
    float lacunarity;
    vec3 offset;
    uint seed;
    float time;
    float density_threshold;
};

// Permutation table for Perlin noise
layout(binding = 2, std430) readonly buffer PermutationBuffer {
    int permutation[512];
};

// 3D gradient vectors (12 edge vectors of a cube)
const vec3 gradients[12] = vec3[](
    vec3(1, 1, 0), vec3(-1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0),
    vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
    vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, 1, -1), vec3(0, -1, -1)
);

// Get gradient vector for hash value
vec3 gradient3d(int hash_value) {
    return gradients[hash_value & 11];
}

// Smooth interpolation function (6t^5 - 15t^4 + 10t^3)
float smoothstep_perlin(float t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Single octave of 3D Perlin noise
float perlin_octave_3d(vec3 pos) {
    // Grid coordinates
    ivec3 grid_pos = ivec3(floor(pos));
    vec3 local_pos = fract(pos);
    
    // Get permutation indices for all 8 cube corners
    int p000 = permutation[permutation[permutation[grid_pos.x & 255] + (grid_pos.y & 255)] + (grid_pos.z & 255)];
    int p001 = permutation[permutation[permutation[grid_pos.x & 255] + (grid_pos.y & 255)] + ((grid_pos.z + 1) & 255)];
    int p010 = permutation[permutation[permutation[grid_pos.x & 255] + ((grid_pos.y + 1) & 255)] + (grid_pos.z & 255)];
    int p011 = permutation[permutation[permutation[grid_pos.x & 255] + ((grid_pos.y + 1) & 255)] + ((grid_pos.z + 1) & 255)];
    int p100 = permutation[permutation[permutation[((grid_pos.x + 1) & 255)] + (grid_pos.y & 255)] + (grid_pos.z & 255)];
    int p101 = permutation[permutation[permutation[((grid_pos.x + 1) & 255)] + (grid_pos.y & 255)] + ((grid_pos.z + 1) & 255)];
    int p110 = permutation[permutation[permutation[((grid_pos.x + 1) & 255)] + ((grid_pos.y + 1) & 255)] + (grid_pos.z & 255)];
    int p111 = permutation[permutation[permutation[((grid_pos.x + 1) & 255)] + ((grid_pos.y + 1) & 255)] + ((grid_pos.z + 1) & 255)];
    
    // Get gradient vectors for all corners
    vec3 grad000 = gradient3d(p000);
    vec3 grad001 = gradient3d(p001);
    vec3 grad010 = gradient3d(p010);
    vec3 grad011 = gradient3d(p011);
    vec3 grad100 = gradient3d(p100);
    vec3 grad101 = gradient3d(p101);
    vec3 grad110 = gradient3d(p110);
    vec3 grad111 = gradient3d(p111);
    
    // Calculate dot products for all corners
    float dot000 = dot(grad000, local_pos);
    float dot001 = dot(grad001, local_pos - vec3(0.0, 0.0, 1.0));
    float dot010 = dot(grad010, local_pos - vec3(0.0, 1.0, 0.0));
    float dot011 = dot(grad011, local_pos - vec3(0.0, 1.0, 1.0));
    float dot100 = dot(grad100, local_pos - vec3(1.0, 0.0, 0.0));
    float dot101 = dot(grad101, local_pos - vec3(1.0, 0.0, 1.0));
    float dot110 = dot(grad110, local_pos - vec3(1.0, 1.0, 0.0));
    float dot111 = dot(grad111, local_pos - vec3(1.0, 1.0, 1.0));
    
    // Smooth interpolation weights
    float u = smoothstep_perlin(local_pos.x);
    float v = smoothstep_perlin(local_pos.y);
    float w = smoothstep_perlin(local_pos.z);
    
    // Trilinear interpolation
    float x00 = mix(dot000, dot100, u);
    float x01 = mix(dot001, dot101, u);
    float x10 = mix(dot010, dot110, u);
    float x11 = mix(dot011, dot111, u);
    
    float y0 = mix(x00, x10, v);
    float y1 = mix(x01, x11, v);
    
    return mix(y0, y1, w);
}

// Multi-octave fractal noise
float fractal_noise_3d(vec3 pos) {
    float value = 0.0;
    float current_amplitude = amplitude;
    float current_frequency = frequency;
    float max_value = 0.0;
    
    for (int i = 0; i < octaves && i < 6; i++) {
        value += perlin_octave_3d(pos * current_frequency) * current_amplitude;
        max_value += current_amplitude;
        
        current_amplitude *= persistence;
        current_frequency *= lacunarity;
    }
    
    return value / max_value;
}

// Ridged noise variation
float ridged_noise_3d(vec3 pos) {
    float noise_value = abs(fractal_noise_3d(pos));
    return 1.0 - noise_value;
}

// Turbulence noise
float turbulence_3d(vec3 pos) {
    float value = 0.0;
    float current_amplitude = amplitude;
    float current_frequency = frequency;
    
    for (int i = 0; i < octaves && i < 6; i++) {
        value += abs(perlin_octave_3d(pos * current_frequency)) * current_amplitude;
        current_amplitude *= persistence;
        current_frequency *= lacunarity;
    }
    
    return value;
}

void main() {
    ivec3 voxel_coord = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 image_size = imageSize(noise_output);
    
    // Check bounds
    if (voxel_coord.x >= image_size.x || voxel_coord.y >= image_size.y || voxel_coord.z >= image_size.z) {
        return;
    }
    
    // Calculate normalized position
    vec3 pos = vec3(voxel_coord) / vec3(image_size) + offset;
    
    // Add time-based animation for dynamic volumetric effects
    pos += vec3(
        sin(time * 0.05 + pos.y * 2.0) * 0.02,
        cos(time * 0.07 + pos.x * 1.5) * 0.02,
        sin(time * 0.06 + pos.z * 1.8) * 0.02
    );
    
    // Generate noise value based on seed parameter
    float noise_value;
    switch (seed % 4) {
        case 0:
            noise_value = fractal_noise_3d(pos);
            break;
        case 1:
            noise_value = ridged_noise_3d(pos);
            break;
        case 2:
            noise_value = turbulence_3d(pos);
            break;
        default:
            // Marble-like pattern
            noise_value = sin(pos.x * 3.0 + turbulence_3d(pos) * 5.0) * 0.5 + 0.5;
            break;
    }
    
    // Normalize to [0, 1] range
    noise_value = (noise_value + 1.0) * 0.5;
    
    // Apply density threshold for volumetric applications
    if (density_threshold > 0.0) {
        noise_value = noise_value > density_threshold ? noise_value : 0.0;
    }
    
    // Output single channel noise value
    imageStore(noise_output, voxel_coord, vec4(noise_value, 0.0, 0.0, 0.0));
}